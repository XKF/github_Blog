# 执行上下文、作用域、作用域链的温固及理解

## 1、执行上下文

执行上下文可以说是评估和执行JavaScript的环境的抽象说法，简单说就是JS执行代码将在哪个环境中执行，即JS代码执行前要进行创建，创建流程后面再说，这里执行上下文可以分为全局执行上下文、函数执行上下文、eval函数执行上下文，我们的JS代码解析执行时，全局执行上下文可以说是最基础最根基的环境，一开始就会创建，而且！！！全局执行上下文一个程序有且只有一个，接着，在执行到函数的时候，又会生成对应函数的执行上下文，也就是对应的执行环境，函数执行上下文可以有多个，eval函数执行上下文亦是如此，这里eval比较少用就略过了。

![image](864F75C3BE354EF2A2ACEB59EC217934)

从执行上下文又牵出了执行栈，按代码解析执行所产生的执行上下文顺序依次压入栈，按照先进后出的顺序，每次执行完栈顶的代码后就将其上下文pop弹出，等待垃圾回收，进入下一个执行上下文，执行完则重复如上操作。那么下面讲一下执行上下文的俩个阶段吧，创建阶段（第2-4点）和执行阶段（第5点）。

## 2、this 指向的绑定
全局执行上下文中，this指向全局对象，Browser中是window对象，Node中是global对象；
函数执行上下文中，this取决于被谁调用，函数被引用对象调用时，this指向该对象，否则指向全局对象或者undefined（严格模式）

![image](DF9569F102944AA9BA25CEC64918165B)

## 3、创建词法环境组件
简单来说就是执行环境中（执行上下文中）存储变量和函数声明的实际位置，以及定义该执行上下文中能访问到的变量等，即创建作用域链，可以当一个area，包裹在执行上下文中，那么词法环境又分为  
- 1、环境记录器：存储变量、函数声明的实际位置；
- 2、外部环境的引用：可以访问父级词法环境（作用域），这也是创建作用域链的关键

词法环境类型：  
- 1、全局环境（位于全局执行上下文中），其外部环境引用为null，最根的词法环境了，其环境记录器有 window对象、用户自定义的全局变量、原型函数等等，在这个环境中this指向全局对象；
- 2、函数环境，函数内部定义的变量，函数声明等记录在环境记录器中，其外部环境引用可能是全局环境，也可能是函数环境。

环境记录器类型：  
- 1、对象环境记录器(全局环境)
- 2、声明式环境记录器(函数环境)   
PS：函数的arguments对象在该环境记录器里

搬了一段伪代码过来

![image](03CC49D450F5483D853D53C006549C03)

## 4、创建变量环境组件

变量环境也是一个词法环境，那为什么要从词法环境里再单独拆出来一个变量环境呢，这里的变量环境作用是用来存储var的变量绑定，而前者则是用来存储函数声明和变量（let 和 const）的绑定。看下下面这个例子

![image](9359FAB4BAD5420A977824C8DC9B6E2C)

![image](D5846EEF5D00440B86B44F3880C82DDA)

图中可以看出在词法环境中，let 和 const没有关联任何值，而在变量环境中var定义的变量初始值被设为了undefined，这也就是es6中用var定义的变量未声明赋值前你可以调用，而let 和 const定义的变量却会得到一个引用错误的原因，换种更熟悉的说法就是var的变量声明提升，它被存储进了变量环境。
额外补充，函数声明提升还是在变量声明提升前面，这点没有变化记得。

## 5、执行阶段
完成存储好的变量的分配，就可以执行代码了，还有，函数执行上下文是在函数调用前才开始创建的，不是一开始就全创建好的。

## 6、题外（作用域+作用域链）
好了，说到这里，是不是突然会有种感觉觉得执行上下文中的词法环境跟作用域很像，但它们是不一样的，不多说，直接上例子。

```js
var A = 1；
function test(){
    let B = 2;
    function inner(){
        const C = 3
        console.log(A)
    }
}
```

![image](FEA63077DBB14901B4FCF5D7C952E760)

上面声明定义A,B,C变量时作用域就已经定义好，因为JS的作用域是静态作用域，初始化时即定义，所以这里就定义好了各个变量作用域涵盖范围，即谁可以访问或使用它，往下去推。

那在执行时比如上面的C函数里输出A要怎么去找到父级作用域的A，这时就需要通过词法环境里的外部环境引用去取得父级词法环境里的变量A，往上去推，如果还找不到就会再继续往上层环境去找，相当通过外部环境引用形成了一条往上找的链接，而这条链接就是作用域链。

总的来说，作用域是初始化时定义，作用域链是创建执行上下文时形成，执行上下文创建阶段的外部环境引用就已经形成通道了，后面执行阶段你子级往上推肯定是能访问到父级作用域里的变量信息，除非都没定义那必定没找到。  

参考链接：https://juejin.cn/post/6844903682283143181
