# 执行上下文、作用域、作用域链的温固及理解

## 1、执行上下文

执行上下文可以说是评估和执行JavaScript的环境的抽象说法，简单说就是JS执行代码将在哪个环境中执行，即JS代码执行前要进行创建，创建流程后面再说，这里执行上下文可以分为**全局执行上下文、函数执行上下文、eval函数执行上下文**，我们的JS代码解析执行时，全局执行上下文可以说是最基础最根基的环境，一开始就会创建，而且！！！**全局执行上下文一个程序有且只有一个**，接着，在执行到函数的时候，又会生成对应函数的执行上下文，也就是对应的执行环境，函数执行上下文可以有多个，eval函数执行上下文亦是如此，这里eval比较少用就略过了。

![avatar](https://github.com/XKF/github_Blog/blob/master/img/example_1.gif)  

从执行上下文又牵出了执行栈，按代码解析执行所产生的执行上下文顺序依次压入栈，按照**先进后出**的顺序，每次执行完栈顶的代码后就将其上下文pop弹出，等待垃圾回收，进入下一个执行上下文，执行完则重复如上操作。那么下面讲一下执行上下文的俩个阶段吧，创建阶段（第2-4点）和执行阶段（第5点）。

## 2、this 指向的绑定
全局执行上下文中，this指向全局对象，Browser中是window对象，Node中是global对象；
函数执行上下文中，this取决于被谁调用，函数被引用对象调用时，this指向该对象，否则指向全局对象或者undefined（严格模式）

![avatar](https://github.com/XKF/github_Blog/blob/master/img/example_2.png)

## 3、创建词法环境组件
简单来说就是执行环境中（执行上下文中）存储变量和函数声明的实际位置，以及定义该执行上下文中能访问到的变量等，即创建作用域链，可以当一个area，包裹在执行上下文中，那么词法环境又分为  
- 1、**环境记录器（变量对象 - Variable Object）**：存储变量、函数声明的实际位置，与作用域息息相关，保存当前一级作用域下的所有函数和变量，注意VO不存储函数表达式；
- 2、**外部环境的引用（是个类 Variable Object）**：可以访问父级词法环境（作用域），其内容为当前词法环境的变量对象 + 父级词法环境变量对象，这也是创建作用域链的关键。

词法环境类型：  
- 1、**全局环境**（其变量对象即为**全局对象 - Global Object**，唯一浏览器可访问的变量对象，被具象给了window），其外部环境引用为null，最根的词法环境了，其环境记录器有window对象、用户自定义的全局变量、原型函数等等，在这个环境中this指向全局对象；
- 2、**函数环境**，函数内部定义的变量，函数声明等记录在环境记录器中，其外部环境引用可能是全局环境，也可能是函数环境。

环境记录器类型：  
- 1、**对象环境记录器**(全局环境)
- 2、**声明式环境记录器**(函数环境)     
PS：函数的arguments对象在该环境记录器里

搬了一段伪代码过来

![avatar](https://github.com/XKF/github_Blog/blob/master/img/example_3.png)  

在创建函数词法环境的环境记录器，即变量对象时，会先创建一个**活动对象 - (Activation Object)**，AO被初始化为[arguments]，随后被并入到后续初始化的变量对象中去，这也就是环境记录器中有arguments的原因。

## 4、创建变量环境组件

变量环境也是一个词法环境，那es6后为什么要从词法环境里再单独拆出来一个变量环境呢，这里的变量环境作用是用来存储var的变量绑定，而前者则是用来存储函数声明和变量（let 和 const）的绑定。看下下面这个例子

![avatar](https://github.com/XKF/github_Blog/blob/master/img/example_4.png)  

![avatar](https://github.com/XKF/github_Blog/blob/master/img/example_5.png)  

图中可以看出在词法环境中，let 和 const没有关联任何值，而在变量环境中var定义的变量初始值被设为了undefined，这也就是es6中用var定义的变量未声明赋值前你可以调用，而let 和 const定义的变量却会得到一个引用错误的原因，换种更熟悉的说法就是var的变量声明提升，它被存储进了变量环境。
额外补充，函数声明提升还是在变量声明提升前面，这点没有变化记得。

## 5、执行阶段
完成存储好的变量的分配，就可以执行代码了，还有，函数执行上下文是在函数调用前才开始创建的，不是一开始就全创建好的。

## 6、题外（作用域+作用域链）
好了，说到这里，是不是突然会有种感觉觉得执行上下文中的词法环境跟作用域很像，但它们是不一样的，不多说，直接上例子。

```js
var A = 1；
function test(){
    let B = 2;
    function inner(){
        const C = 3
        console.log(A)
    }
}
```

![avatar](https://github.com/XKF/github_Blog/blob/master/img/example_6.png)  

上面声明定义A,B,C变量时作用域就已经定义好，因为JS的作用域是静态作用域，初始化时即定义，所以这里就定义好了执行时各变量的绑定关系，取哪里的值。

那在执行时比如上面的C函数里输出A要怎么去找到父级作用域的A，这时就需要通过词法环境里的外部环境引用去取得父级词法环境里的变量A。

首先，我们这里把A当全局执行上下文，在执行全局执行上下文时，其会将当前作用域下的变量、函数声明等进行初始化，形成变量对象，然后复制A的一个私有属性 [[Scope]] (这个属性就是用来管作用域的，保存在外部引用环境中，保留着自身作用域绑定关系及相关指针)，然后将变量对象拷贝并到一起形成 [[Scope Chain A]] 对象，也就是作用域链的链头。

接着，B的词法环境的外部环境引用保存着一个指向A的 [[Scope Chain A]] 的指针，即 [[Scope B]] 里，这里B的执行上下文就可以通过自己的 [[Scope]] 属性里 [[Scope Chain A]] 的指针摸上去访问到A的变量信息了，同时将 [[Scope Chain A]] 的指针和自己的变量对象合并成 [[Scope Chain B]] ，同理，C也是如此，其通过外部环境引用里的 [[Scope Chain B]] 的指针， [[Scope Chain B]] 里有 [[Scope Chain A]] 的指针，那么就可以依次访问到B和A的变量信息了，环环相扣，是不是一条链，C的作用域链就构建完成了。

总的来说，作用域是初始化时定义（变量的取值绑定），作用域链是创建执行上下文时形成（怎么去拿），执行上下文创建阶段通过外部环境引用创建起访问上层变量信息通道。

但但但是，还有一个特别例子，当某个函数返回使用到外部作用域变量的匿名函数时，也就是我们常说的闭包，管作用域的私有属性 [[Scope]] 决定了在执行上下文被销毁时，由于某个变量还被绑定引用着，该变量在内存中会被单独留了下来供后续使用，因而没被垃圾回收，也即执行上下文弹出后垃圾回收执行环境中的东西时仍被引用的变量不被回收。


参考链接：
- https://juejin.cn/post/6844903682283143181
- https://github.com/kuitos/kuitos.github.io/issues/18
